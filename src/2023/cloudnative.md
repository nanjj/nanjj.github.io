## 0

简单原则：
> KISS - Keep It Simple and Stupid

是UNIX哲学的根本原则。

## 1

阮一峰把简单原则打开，按代码、模块、接口、系统的层次，落实为具体可执行：
1. 代码清晰给人看，众人拾柴火焰高，
2. 模块解耦功能少，个人终归力量小，
3. 接口组合很重要，聚沙成塔大事成，
4. 不要急于做优化，先跑起来最重要。

## 2

Worse is better的表述:

1. 简单最重要，实现简单尤为重要，
2. 即使部分不正确，也要简单，
3. 即使局部不一致，也要简单，
4. 即使功能不完备，也要简单。

## 3

一段 UNIX 早期公案：

一个应用正在调用一个慢系统调用，比如`read`，收到一个中断信号。问：
1. 系统调用该如何处理？
2. 应用该如何处理？

UNIX给出的解决方案如下：

```
again:
if ((n = read(fd, buf, BUFFSIZE)) < 0) {
  if (errno == EINTR)
    goto again;  /* just an interrupted system call */
  /* handle other errors */
}
```

UNIX 认为系统调用只需要标记`errno`为`EINTR`,退出即可。用户应用需要处理
`errno == EINTR`，重试就行。这个方案从UNIX角度看是简单的。

以下接圣经式微言大义的描述。

两个大师，一个来自麻省理工，另一个来自伯克利，一天谋面讨论这个操作系统
问题。伯克利大师（以下简称伯）参与写UNIX源码。麻省大师（以下简称麻）学
识渊博，在麻省理工人工智能操作系统方面，并且已经熟读UNIX源码。他与伯克
利大师谋面，想仔细探讨以上问题。于是很快他就得知了真相。

麻：

> 这是不正确的！当中断来临，系统要记下用户进程的状态, 执行中断，并在中
> 断结束后，继续用户进程的执行。对用户而言，就像中断没有发生一样。这样
> 接口的设计也是一致的。而不必引入一个丑陋的`errno`。你看`errno`并没有
> 在`read`接口中出现。接口是契约，契约就是法律。自己定的法律自己就要遵
> 守。

伯：

> 这的确不正确，但这实现简单，并在用户可见的方面正确。UNIX相信简单实现
> 随时间演进，最终会达到完整的正确。

麻：

> 为什么不一次把事情完全做对呢？

伯：

> 因为程序员都是凡人吧，不是上帝。不够聪明，能正确理解用户当下的需求就
> 很好了，不能预测将来；没有无限的时间投在代码实现上，能把当下能看到的
> 正确实现就不错了，下次维护这篇代码的，很可能是另一个人。
>
> 因此一个不很聪明的程序员，在有限的时间内，不能保证实现绝对正确，但要
> 确保实现简单，简单的种子持续演化，也许最终也许能逼近正确。

麻：

> 为什么不是一个强人，操起把牛刀，把一只小弱鸡给宰了呢？

伯：

> 首先无有小弱鸡待宰。代码要工作，最好当天就要工作，而不是几个月或
> 一年，在把所有能考虑到的方面都考虑到，甚至不能考虑到的也要猜出来，才
> 工作。
>
> 其次牛刀不存在。牛刀永远在打造途中，在路上，在理想里。在现实里只有双
> 手可以依赖。
>
> 最后没有强人。所谓胜人者有力，胜己者强。而要进步，就得了解自己的局限，就得谦虚。

麻：

> 我明白你的意思了。

